package maidsafe.priv.process_management.protobuf;

// All following messages are serialised into the payload field, and the message type added.
message WrapperMessage {
  required int32 type = 1;
  required bytes payload = 2;
  optional bytes message_signature = 3;
}

// Invigilator receives this from a Client looking for the correct port and echos it back.
message ClientRegistrationRequest {
  required uint32 listening_port = 1;  // generated by ClientController
  required int32 version = 2;
}

message ClientRegistrationResponse {
  repeated bytes bootstrap_endpoint_ip = 1;
  repeated uint32 bootstrap_endpoint_port = 2;
  optional bytes path_to_new_installer = 3;
}

// Invigilator receives this from Client and it will then start a vault.  The new vault will send
// a VaultIdentityRequest to the Invigilator which will trigger the StartVaultResponse in reply to
// this message.
message StartVaultRequest {
  required bytes account_name = 1;
  required bytes keys = 2;
  required bytes token = 3;
  required bytes token_signature = 4;
  required bool credential_change = 5;
  required uint32 client_port = 6;
}

// Invigilator sends this in response to a StartVaultRequest. It details whether or not the
// starting of the vault was successful.
message StartVaultResponse {
  required bool result = 1;
}

// Invigilator receives this from Vault. Vault expects a VaultIdentityResponse.
message VaultIdentityRequest {
  required uint32 process_index = 1;  // as assigned by ProcessManager
  required uint32 listening_port = 2;  // generated by VaultController
  required int32 version = 3;
}

// Invigilator sends this to a requesting Vault. It contains the ID that the Vault can assume,
// plus bootstrap nodes.
message VaultIdentityResponse {
  required bytes account_name = 1;
  required bytes keys = 2;
  required bytes chunkstore_path = 3;
  repeated bytes bootstrap_endpoint_ip = 4;
  repeated uint32 bootstrap_endpoint_port = 5;
}

// Invigilator receives this from Vault once it has joined or failed to join the network and
// replies with the VaultJoinedNetworkAck.
message VaultJoinedNetwork {
  required uint32 process_index = 1;  // as assigned by ProcessManager
  required bool joined = 2;
}

message VaultJoinedNetworkAck {
  required bool ack = 1;
}

// Client receives this from Invigilator once Vault has joined or failed to join the network and
// Client replies with the VaultJoinConfirmationAck.
message VaultJoinConfirmation {
  required bytes identity = 1;
  required bool joined = 2;
}

message VaultJoinConfirmationAck {
  required bool ack = 1;
}

//Vault sends this to Invigilator when it discovers a suitable bootstrap node.
// Invigilator replies with the SendEndpointToInvigilatorResponse.
message SendEndpointToInvigilatorRequest {
  required bytes bootstrap_endpoint_ip = 4;
  required uint32 bootstrap_endpoint_port = 5;
}

message SendEndpointToInvigilatorResponse {
  required bool result = 1;
}

// Invigilator receives this from Client and it will then stop vault with keys.identity==identity
message StopVaultRequest {
  required bytes data = 1;
  required bytes signature = 2;
  required bytes identity = 3;
}

// Invigilator sends this in response to a StopVaultRequest. It details whether or not the
// stopping of the vault was successful.
message StopVaultResponse {
  required bool result = 1;
}

// Invigilator sends this to Vault
message VaultShutdownRequest {
  required uint32 process_index = 1;  // as assigned by ProcessManager
  required bytes data = 2;
  required bytes signature = 3;
}

// Vault replies with this to a requesting Invigilator. It contains a boolean indicating whether
// or not the vault is shutting down.
message VaultShutdownResponse {
  required bool shutdown = 1;
  required uint32 process_index = 2;
}

// Invigilator acknowledges VaultShutdownResponse with this.
message VaultShutdownResponseAck {
  required bool ack = 1;
}

// Client sends this to Invigilator.  If the new_update_interval is set, the request is a setter,
// otherwise it's a getter.
message UpdateIntervalRequest {
  optional uint32 new_update_interval = 1;  // In seconds.
}

// Invigilator sends this to a requesting Client indicating current update interval in seconds.
message UpdateIntervalResponse {
  required uint32 update_interval = 1;  // In seconds.
}

// Invigilator sends this to Clients when a new version of the Client executable is available.
message NewVersionAvailable {
  required bytes new_version_filepath = 1;
}

// Client acknowledges NewVersionAvailable by replying with the same new_version_filepath that was
// passed in the NewVersionAvailable message.
message NewVersionAvailableAck {
  required bytes new_version_filepath = 1;
}

message BootstrapRequest {
  required uint32 message_id = 1;
}

message BootstrapResponse {
  repeated bytes bootstrap_endpoint_ip = 1;
  repeated uint32 bootstrap_endpoint_port = 2;
}
